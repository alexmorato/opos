<!DOCTYPE html>
<html lang="ca">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Estudi - sTIC d'Opos</title>

  <link rel="icon" type="image/png" sizes="16x16" href="images/icons/favicon-16x16.png">
  <link rel="icon" type="image/png" sizes="32x32" href="images/icons/favicon-32x32.png">
  <link rel="icon" href="images/icons/favicon.ico" type="image/x-icon">
  <link rel="apple-touch-icon" sizes="180x180" href="images/icons/apple-touch-icon.png">
  <link rel="manifest" href="images/icons/site.webmanifest">
  <link rel="icon" type="image/png" sizes="192x192" href="images/icons/android-chrome-192x192.png">
  <link rel="icon" type="image/png" sizes="512x512" href="images/icons/android-chrome-512x512.png">
  <style>
    .question-info {
      font-size: 0.93rem;
      color: #9fb0ff;
      margin-bottom: 7px;
    }
    body { font-family: system-ui, sans-serif; background: #0b1020; color: #e7ecff; margin: 0; padding: 10px; }
    .container { max-width: 800px; margin: 0 auto; }
    .header {
      text-align: center;
      color: #6ae0a7;
      font-size: 1.8rem;
      font-weight: bold;
      margin-bottom: 10px;
    }
    .progress-bar {
      width: 100%;
      height: 8px;
      background: #27304a;
      border-radius: 4px;
      /* margin-bottom: 30px; */
      overflow: hidden;
    }
    .progress-fill {
      height: 100%;
      background: linear-gradient(90deg, #6ae0a7, #2aebad);
      transition: width 0.3s ease;
    }
    .question-card {
      background: #141a2a;
      border: 1.5px solid #27304a;
      border-radius: 12px;
      padding: 15px;
      margin-bottom: 10px;
      box-shadow: 0 4px 20px rgba(0,0,0,0.3);
    }
    .question-number {
      font-size: 1rem;
      color: #9fb0ff;
      margin-bottom: 15px;
    }
    .question-text {
      font-size: 1.1rem;
      line-height: 1.5;
      margin-bottom: 25px;
      color: #e7ecff;
    }
    .answer-option {
      background: #27304a;
      border: 2px solid #2a3554;
      border-radius: 10px;
      padding: 5px 10px;
      margin: 10px 0;
      cursor: pointer;
      transition: all 0.2s ease;
      display: flex;
      align-items: center;
      font-size: 1.1rem;
    }
    .answer-option:hover {
      border-color: #6ae0a7;
      background: #2a3554;
    }
    .answer-option.selected {
      border-color: #6ae0a7;
      background: rgba(106, 224, 167, 0.1);
      color: #6ae0a7;
    }
    .answer-option.correct {
      border-color: #6ae0a7;
      background: rgba(106, 224, 167, 0.2);
    }
    .answer-option.incorrect {
      border-color: #ff6b6b;
      background: rgba(255, 107, 107, 0.2);
    }
    .answer-option.flashcard-hidden {
      background: #232b45;
      color: #9fb0ff;
      border-color: #2a3554;
    }
    .answer-option.flashcard-revealed {
      background: #0f1525;
      border-color: #6ae0a7;
      color: #e7ecff;
    }
    .option-content {
      flex: 1;
    }
    .option-text {
      color: #e7ecff;
      margin-bottom: 5px;
      transition: all 0.3s ease;
    }
    .option-text.hidden {
      opacity: 0.3;
      transform: scale(0.95);
    }
    .feedback {
      font-weight: bold;
      margin: 10px 0 5px 0;
      font-size: 1rem;
    }
    .correct-feedback {
      color: #6ae0a7;
    }
    .incorrect-feedback {
      color: #ff6b6b;
    }
    .rationale {
      color: #c2d3ff;
      font-style: italic;
      font-size: 0.95rem;
      line-height: 1.4;
      margin-top: 5px;
    }
    .explanation {
      background: #0f1525;
      border-left: 4px solid #6ae0a7;
      padding: 20px;
      margin-top: 20px;
      border-radius: 0 8px 8px 0;
      font-style: italic;
      color: #c2d3ff;
    }
    .navigation {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-top: 10px;
    }
    .nav-btn {
      background: linear-gradient(180deg, #2aebad, #21c08d);
      color: #032217;
      font-weight: bold;
      font-size: 1.1rem;
      padding: 12px 24px;
      border-radius: 10px;
      border: none;
      cursor: pointer;
      transition: all 0.2s;
    }
    .nav-btn:disabled {
      opacity: 0.5;
      pointer-events: none;
    }
    .nav-btn.secondary {
      background: #27304a;
      color: #e7ecff;
    }
    .nav-btn:hover:not(:disabled) {
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(42, 235, 173, 0.3);
    }
    .results {
      text-align: center;
      padding: 40px 20px;
    }
    .score {
      font-size: 3rem;
      font-weight: bold;
      color: #6ae0a7;
      margin-bottom: 20px;
    }
    .score-text {
      font-size: 1.3rem;
      margin-bottom: 30px;
      color: #9fb0ff;
    }
    .historial-section {
      margin-top: 40px;
      padding-top: 30px;
      border-top: 1px solid #27304a;
    }
    .historial-buttons {
      display: flex;
      gap: 10px;
      margin-bottom: 15px;
      flex-wrap: wrap;
    }
    .historial-btn {
      background: #27304a;
      color: #e7ecff;
      font-size: 0.9rem;
      padding: 8px 16px;
      border-radius: 6px;
      border: 1px solid #2a3554;
      cursor: pointer;
      transition: all 0.2s;
    }
    .historial-btn:hover {
      background: #2a3554;
      border-color: #6ae0a7;
    }
    .historial-btn.remove-btn {
      background: #4a2727;
      border-color: #6b4040;
    }
    .historial-btn.remove-btn:hover {
      background: #6b4040;
      border-color: #ff6b6b;
      color: #ff6b6b;
    }
    .historial-btn:disabled {
      opacity: 0.4;
      cursor: not-allowed;
      pointer-events: none;
    }
    .historial-textarea {
      width: 100%;
      min-height: 200px;
      background: #141a2a;
      border: 1px solid #27304a;
      border-radius: 8px;
      color: #e7ecff;
      font-family: monospace;
      font-size: 0.85rem;
      padding: 15px;
      resize: vertical;
      box-sizing: border-box;
    }
    .historial-title {
      color: #6ae0a7;
      font-size: 1.1rem;
      font-weight: bold;
      margin-bottom: 10px;
    }
    .hint-area {
      background: #232b45;
      color: #9fb0ff;
      border-radius: 8px;
      padding: 12px 18px;
      margin: 0 0 18px 0;
      text-align: center;
      font-size: 1.05rem;
      cursor: pointer;
      user-select: none;
      transition: background 0.2s, color 0.2s;
      border: 1.5px solid #27304a;
      max-width: 800px;
      margin-left: auto;
      margin-right: auto;
    }
    .hint-area.mostrando {
      background: #0f1525;
      color: #e7ecff;
      font-weight: bold;
    }
    #cronometroAnchor {
      position: fixed;
      right: 12px;
      bottom: 12px;
      z-index: 9999;
    }
    #cronometroBox {
      background: #ffe066;
      color: #27304a;
      border-radius: 18px;
      padding: 6px 8px;
      font-size: 1.5rem;
      font-weight: bold;
      box-shadow: 0 4px 18px #0005;
      cursor: pointer;
      transition: background 0.2s, color 0.2s;
      border: 2.5px solid #27304a;
      user-select: none;
    }
  </style>
  <script src="assets/js/toast.js"></script>
  <script src="assets/js/localstorage-utils.js"></script>
</head>
<body>
  <div class="container">
  <div class="header" id="headerTitle">‚òï Estic d'opos ‚òï</div>
  <script>
    // Fullscreen toggle al clicar el header
    document.addEventListener('DOMContentLoaded', function() {
      const header = document.getElementById('headerTitle');
      header.style.cursor = 'pointer';
      header.title = 'Clica per a pantalla completa';
      header.addEventListener('click', function() {
        if (!document.fullscreenElement) {
          document.documentElement.requestFullscreen();
        } else {
          document.exitFullscreen();
        }
      });
    });
    // Cargar headerTitle din√°micamente desde config.json, igual que en index.html
    fetch('assets/config.json')
      .then(r => r.json())
      .then(cfg => {
        if (cfg.headerTitle) {
          let title = cfg.headerTitle;
          if (cfg.headerTitleSectionText) {
            let section = '';
            const params = new URLSearchParams(window.location.search);
            if (params.has('section')) {
              section = params.get('section');
            }
            title = title.replace(cfg.headerTitleSectionText, section);
          }
          document.getElementById('headerTitle').textContent = title;
        }
      });
  </script>
    
    <div class="progress-bar">
      <div class="progress-fill" id="progressFill"></div>
    </div>


  <div id="questionContainer"></div>

  <div id="hintArea" class="hint-area" onclick="mostrarHint()">pista</div>


  <div id="removeFromHistoryContainer" style="text-align:center;margin:10px 0; display:none;">
    <button class="historial-btn remove-btn" id="removeFromHistoryBtn" onclick="eliminarDelHistorial()" disabled>‚úÖ Eliminar encertada</button>
  </div>
  <!-- Cron√≥metro anclado -->
  <div id="cronometroAnchor">
    <div id="cronometroBox">00:00</div>
  </div>

    <div class="navigation">
      <button class="nav-btn secondary" id="prevBtn" onclick="previousQuestion()">‚Üê Anterior</button>
      <span id="questionCounter"></span>
      <button class="nav-btn" id="nextBtn" onclick="nextQuestion()">Seg√ºent ‚Üí</button>
    </div>

    <div class="historial-section">
  <div class="historial-title">Historial fallos <span id="fallosCount" style="color:#9fb0ff;font-weight:normal;font-size:0.98em;"></span></div>
      <div class="historial-buttons">
        <button class="historial-btn" onclick="copiarHistorial()">üìã Copia</button>
        <button class="historial-btn" onclick="baixarHistorial()">üíæ Baixa</button>
        <button class="historial-btn" onclick="guardarDubte()">‚ùì Guardar dubte</button>
        <button class="historial-btn" onclick="esborrarHistorial()">üóëÔ∏è Esborrar tot</button>
      </div>
      <textarea class="historial-textarea" id="historialFallos" readonly placeholder="Aqu√≠ apareixeran les preguntes fallades..."></textarea>
    </div>

    <div style="text-align:center;margin:40px 0 10px 0;">
      <button onclick="window.location.href='menu.html'" style="background:#27304a;color:#e7ecff;font-size:1.1rem;padding:14px 38px;border-radius:12px;border:none;cursor:pointer;transition:background 0.2s;">‚¨ÖÔ∏è Tornar al men√∫</button>
    </div>
  </div>

  <script>
    // --- Cron√≥metro anclado ---
    let cronometroInterval = null;
    let cronometroStart = null;
    let cronometroElapsed = 0;
    let cronometroRunning = false;
    const cronometroBox = document.getElementById('cronometroBox');
    let cronometroSaveInterval = null;

    function formatTime(ms) {
      const totalSec = Math.floor(ms / 1000);
      const min = Math.floor(totalSec / 60);
      const sec = totalSec % 60;
      return (min < 10 ? '0' : '') + min + ':' + (sec < 10 ? '0' : '') + sec;
    }
    function updateCronometroDisplay() {
      let ms = cronometroElapsed;
      if (cronometroRunning && cronometroStart) {
        ms += Date.now() - cronometroStart;
      }
      cronometroBox.textContent = formatTime(ms);
      if (cronometroRunning) {
        cronometroBox.style.background = 'linear-gradient(90deg,#6ae0a7,#2aebad)';
        cronometroBox.style.color = '#032217';
        cronometroBox.style.borderColor = '#21c08d';
        cronometroBox.style.boxShadow = '0 4px 18px #21c08d55';
      } else {
        cronometroBox.style.background = '#ffe066';
        cronometroBox.style.color = '#27304a';
        cronometroBox.style.borderColor = '#27304a';
        cronometroBox.style.boxShadow = '0 4px 18px #0005';
      }
    }
    function saveCronometroToLocalStorage() {
      let ms = cronometroElapsed;
      if (cronometroRunning && cronometroStart) {
        ms += Date.now() - cronometroStart;
      }
      localStorage.setItem(LS_KEYS.CRONOMETRO, ms);
    }
    function startCronometro() {
      if (cronometroRunning) return;
      cronometroRunning = true;
      cronometroStart = Date.now();
      cronometroInterval = setInterval(updateCronometroDisplay, 500);
      // Save every 20 seconds
      if (cronometroSaveInterval) clearInterval(cronometroSaveInterval);
      cronometroSaveInterval = setInterval(saveCronometroToLocalStorage, 20000);
      updateCronometroDisplay();
    }
    function stopCronometro() {
      if (!cronometroRunning) return;
      cronometroRunning = false;
      cronometroElapsed += Date.now() - cronometroStart;
      cronometroStart = null;
      clearInterval(cronometroInterval);
      if (cronometroSaveInterval) clearInterval(cronometroSaveInterval);
      saveCronometroToLocalStorage();
      updateCronometroDisplay();
    }
    cronometroBox.addEventListener('click', function() {
      if (cronometroRunning) {
        stopCronometro();
      } else {
        startCronometro();
      }
    });
    updateCronometroDisplay();
    let preguntes = [];
    let currentQuestion = 0;
    let answers = [];
    let showingResults = false;
    let historialFallos = [];
    let isRepassingErrors = false;
    let canRemoveFromHistory = false;
    let inactivityTimeout = null;
    const INACTIVITY_LIMIT_MS = 2 * 60 * 1000; // 2 minutes

    function resetInactivityTimer() {
      if (inactivityTimeout) clearTimeout(inactivityTimeout);
      inactivityTimeout = setTimeout(() => {
        if (cronometroRunning) {
          stopCronometro();
          toast && toast.showToast ? toast.showToast('Cron√≤metre parat per inactivitat') : null;
        }
      }, INACTIVITY_LIMIT_MS);
    }

    // Mostrar y ocultar hint
    function mostrarHint() {
      const hintDiv = document.getElementById('hintArea');
      if (!hintDiv.classList.contains('mostrando')) {
        const pregunta = preguntes[currentQuestion];
        let hint = pregunta && (pregunta.hint || pregunta.pista || pregunta.clue);
        // Si es tipo flashcard, ofuscar el rationale del answerOption correcto
        if (pregunta && pregunta.type === 'flashcard' && Array.isArray(pregunta.answerOptions)) {
          const correctOption = pregunta.answerOptions.find(opt => opt.isCorrect && opt.rationale);
          if (correctOption && correctOption.rationale) {
            hint = correctOption.rationale.replace(/(\w{2})(\w+)([\.,;:!?¬ø¬°()\[\]{}"'`]*)/g, function(match, p1, p2, p3) {
              return p1 + '*'.repeat(p2.length) + p3;
            });
          } else {
            hint = '(No hi ha pista per aquesta pregunta)';
          }
        }
        hintDiv.textContent = hint ? hint : '(No hi ha pista per aquesta pregunta)';
        hintDiv.classList.add('mostrando');
      }
    }

    function ocultarHint() {
      const hintDiv = document.getElementById('hintArea');
      hintDiv.textContent = 'pista';
      hintDiv.classList.remove('mostrando');
    }
    // --- Mapeo de dificultat ---
    let difficultyMap = {};
    fetch('assets/difficulty.json')
      .then(r => r.json())
      .then(arr => {
        arr.forEach(d => { difficultyMap[d.id] = d.text; });
      });

    function getDifficultyText(difficulty) {
      if (!difficulty) return 'D?';
      return difficultyMap[difficulty] || 'D?';
    }

  // Cargar preguntas o flashcards del localStorage
  function loadQuestions() {
      try {
        // Si repassarErrores=1 en la URL, cargar solo historial de fallos
        const params = new URLSearchParams(window.location.search);
        if (params.get('repassarErrores') === '1') {
          isRepassingErrors = true;
          preguntes = JSON.parse(localStorage.getItem(LS_KEYS.HISTORIAL_FALLOS));
          document.getElementById('removeFromHistoryContainer').style.display = 'block';
        } else {
          isRepassingErrors = false;
          preguntes = JSON.parse(localStorage.getItem(LS_KEYS.PREGUNTES) || '[]');
          // Si no estamos en modo repaso de errores, desactivar el bot√≥n de eliminar del historial
          document.getElementById('removeFromHistoryContainer').style.display = 'none';
        }

        if (!preguntes.length) {
          let msg;
          if (isRepassingErrors) {
            msg = 'No hi ha errors guardats per repassar.';
          } else {
            msg = 'No hi ha preguntes o flashcards carregades.';
          }
          document.getElementById('questionContainer').innerHTML = 
            `<div class="question-card"><div class="question-text">${msg}</div></div>`;
          document.getElementById('removeFromHistoryContainer').style.display = 'none';
          return false;
        }

        // Inicializar el array de respuestas
        answers = new Array(preguntes.length).fill(null);
        // ordenar aleatoriamente las preguntas
        preguntes = preguntes.sort(() => Math.random() - 0.5);
        // Ordenar aleatoriamente las opciones de respuesta de cada pregunta
        preguntes.forEach(q => {
          if (Array.isArray(q.answerOptions)) {
            q.answerOptions = q.answerOptions.sort(() => Math.random() - 0.5);
          }
        });
        // Guardar las preguntas barrejades en localStorage
        localStorage.setItem(LS_KEYS.PREGUNTES_BARREJADES, JSON.stringify(preguntes));
        return true;
      } catch (e) {
        document.getElementById('questionContainer').innerHTML = 
          '<div class="question-card"><div class="question-text">Error carregant les dades.</div></div>';
        return false;
      }
    }

    // Mostrar pregunta actual
    function showQuestion(index) {
      if (index < 0 || index >= preguntes.length) return;
      
      const pregunta = preguntes[index];
      const container = document.getElementById('questionContainer');

      ocultarHint();
      
      // Modo preguntas normal
      let html = `
        <div class="question-card">
          <div class="question-info">
            ${(pregunta.subjectId || '??') + '-' + (pregunta.origin || '??') + '-' + getDifficultyText(pregunta.difficulty)}
          </div>
          <div class="question-text">${pregunta.pregunta || pregunta.question || 'Pregunta no disponible'}</div>
      `;

      // Obtener opciones de respuesta (answerOptions)
      const answerOptions = pregunta.answerOptions || [];
      const opciones = answerOptions;
      const userAnswered = answers[index] !== null;

      opciones.forEach((option, i) => {
        const isSelected = answers[index] === i;
        let optionClass = 'answer-option';
        let extraOnClick = '';
        if (userAnswered) {
          if (option.isCorrect) {
            optionClass += ' correct';
            extraOnClick = `onclick=\"nextQuestion()\"`;
          } else if (isSelected && !option.isCorrect) {
            optionClass += ' incorrect';
            extraOnClick = `onclick=\"nextQuestion()\"`;
          } else {
            extraOnClick = '';
          }
        } else if (isSelected) {
          optionClass += ' selected';
        }
        // Si no est√° respondida, sigue usando selectAnswer
        if (!userAnswered) {
          extraOnClick = `onclick=\"selectAnswer(${i})\"`;
        }
        html += `
          <div class="${optionClass}" ${extraOnClick}>
            <div class="option-content">
              <div class="option-text">${option.text}</div>`;
        // Mostrar feedback si ya se respondi√≥
        if (userAnswered) {
          if (option.isCorrect) {
            html += `
              <div class="feedback correct-feedback">‚úîÔ∏è Resposta correcta</div>
              <div class="rationale">${option.rationale || ''}</div>`;
          } else if (isSelected && !option.isCorrect) {
            html += `
              <div class="feedback incorrect-feedback">‚ùå Resposta incorrecta</div>
              <div class="rationale">${option.rationale || ''}</div>`;
          }
        }
        html += `
            </div>
          </div>
        `;
      });

      html += '</div>';
      container.innerHTML = html;
          
      // Actualizar contador y progreso
      document.getElementById('questionCounter').textContent = `${index + 1} / ${preguntes.length}`;
      const progressPercent = ((index + 1) / preguntes.length) * 100;
      document.getElementById('progressFill').style.width = progressPercent + '%';

      // Guardar el √≠ndice de la pregunta actual en localStorage
      localStorage.setItem(LS_KEYS.PREGUNTA_POSITION, index);

      // Actualizar botones de navegaci√≥n
      document.getElementById('prevBtn').disabled = index === 0;
      document.getElementById('nextBtn').textContent = 
        index === preguntes.length - 1 ? 'Finalitzar' : 'Seg√ºent ‚Üí';

      resetInactivityTimer();
    }

    // Seleccionar respuesta
    function selectAnswer(optionIndex) {
      if (showingResults) return;
      if (answers[currentQuestion] !== null) return; // No permitir cambiar respuesta

      answers[currentQuestion] = optionIndex;

      // Guardar respuestas en localStorage
      localStorage.setItem(LS_KEYS.ANSWERS, JSON.stringify(answers));

      // Verificar si la respuesta es correcta o incorrecta
      const opciones = preguntes[currentQuestion].answerOptions || [];
      const selectedOption = opciones[optionIndex];

      if (selectedOption && selectedOption.isCorrect && isRepassingErrors) {
        // Si acertamos en modo repaso de errores, activar bot√≥n para eliminar
        canRemoveFromHistory = true;
        document.getElementById('removeFromHistoryBtn').disabled = false;
      } else {
        // Desactivar bot√≥n si no es correcto o no estamos en modo repaso
        canRemoveFromHistory = false;
        document.getElementById('removeFromHistoryBtn').disabled = true;
      }

      if (selectedOption && !selectedOption.isCorrect && !isRepassingErrors) {
        // Solo guardar en historial si NO estamos repasando errores
        guardarFalloEnHistorial(currentQuestion, optionIndex);
      }

      // Iniciar el cron√≥metro si est√° parado
      if (!cronometroRunning) {
        startCronometro();
      }

      showQuestion(currentQuestion);
    }


    // Mostrar resultados finals
    function showResults() {
      showingResults = true;
      
      let correctAnswers = 0;
      
      preguntes.forEach((pregunta, index) => {
        const opciones = pregunta.answerOptions || [];
        const selectedOption = opciones[answers[index]];
        if (selectedOption && selectedOption.isCorrect) {
          correctAnswers++;
        }
      });
      
      const percentage = Math.round((correctAnswers / preguntes.length) * 100);
      
      const container = document.getElementById('questionContainer');
      container.innerHTML = `
        <div class="question-card results">
          <div class="score">${percentage}%</div>
          <div class="score-text">
            Has encertat ${correctAnswers} de ${preguntes.length} preguntes
          </div>
          <button class="nav-btn" onclick="reviewAnswers()">Revisar respostes</button>
          <button class="nav-btn secondary" onclick="restartTest()" style="margin-left: 15px;">Tornar a comen√ßar</button>
        </div>
      `;
      
      // Ocultar navegaci√≥n
      document.querySelector('.navigation').style.display = 'none';
    }

    // Revisar respuestas (mostrar correctas e incorrectas)
    function reviewAnswers() {
      showingResults = false;
      currentQuestion = 0;
      showQuestion(0);
      document.querySelector('.navigation').style.display = 'flex';
      document.getElementById('nextBtn').textContent = 'Seg√ºent ‚Üí';
    }

    // Reiniciar test
    function restartTest() {
      currentQuestion = 0;
      answers = new Array(preguntes.length).fill(null);
      showingResults = false;
      showQuestion(0);
      document.querySelector('.navigation').style.display = 'flex';
    }

    // Navegaci√≥n en modo revisi√≥n
    function nextQuestion() {
      if (currentQuestion < preguntes.length - 1) {
        currentQuestion++;
        showQuestion(currentQuestion);
      } else {
        showResults();
      }
      resetInactivityTimer();
    }

    function previousQuestion() {
      if (currentQuestion > 0) {
        currentQuestion--;
        if (showingResults) {
          showQuestionWithAnswers(currentQuestion);
        } else {
          showQuestion(currentQuestion);
        }
      }
      resetInactivityTimer();
    }

    // Guardar fallo en historial
    function guardarFalloEnHistorial(questionIndex, selectedOptionIndex) {
      const pregunta = JSON.parse(JSON.stringify(preguntes[questionIndex])); // Deep copy
      const opciones = pregunta.answerOptions || [];
      const username = localStorage.getItem(LS_KEYS.USER_NAME) || 'unknown';
      // A√±adir username y fecha a la pregunta
      pregunta.username = username;
      pregunta.fecha = new Date().toISOString();
      // Marcar la opci√≥n seleccionada por el usuario
      if (pregunta.answerOptions) {
        pregunta.answerOptions.forEach((option, i) => {
          const shuffledIndex = opciones.findIndex(shuffled => shuffled.text === option.text);
          if (shuffledIndex === selectedOptionIndex) {
            option.selectedByUser = true;
          }
        });
      }
      // A√±adir al principio del historial (m√°s nuevo primero)
      historialFallos.unshift(pregunta);
      actualizarTextareaHistorial();
      localStorage.setItem(LS_KEYS.HISTORIAL_FALLOS, JSON.stringify(historialFallos));
    }

    // Guardar duda actual (independiente de si es correcta o no)
    function guardarDubte() {
      if (currentQuestion >= 0 && currentQuestion < preguntes.length) {
        // L√≥gica original para preguntas
        const userAnswer = answers[currentQuestion];
        if (userAnswer !== null) {
          guardarFalloEnHistorial(currentQuestion, userAnswer);
        } else {
          const pregunta = JSON.parse(JSON.stringify(preguntes[currentQuestion]));
          const username = localStorage.getItem(LS_KEYS.USER_NAME) || 'unknown';
          pregunta.username = username;
          pregunta.fecha = new Date().toISOString();
          historialFallos.unshift(pregunta);
          actualizarTextareaHistorial();
          localStorage.setItem(LS_KEYS.HISTORIAL_FALLOS, JSON.stringify(historialFallos));
        }
      }
    }

    // Eliminar pregunta actual del historial de fallos
    function eliminarDelHistorial() {
      if (!canRemoveFromHistory || !isRepassingErrors) return;
      // Encontrar la pregunta actual en el historial original
      const preguntaActual = preguntes[currentQuestion];
      const guid = preguntaActual.guid;
      // Recargar historial actual del localStorage
      const historialActual = localStorage.getItem(LS_KEYS.HISTORIAL_FALLOS);
      if (historialActual) {
        historialFallos = JSON.parse(historialActual);
        // Eliminar todas las preguntas que coincidan con el guid
        if (guid) {
          historialFallos = historialFallos.filter(p => p.guid !== guid);
        } else {
          // Si no hay guid, eliminar por pregunta/question como antes
          historialFallos = historialFallos.filter(p => !(p.pregunta === preguntaActual.pregunta || p.question === preguntaActual.question));
        }
        localStorage.setItem(LS_KEYS.HISTORIAL_FALLOS, JSON.stringify(historialFallos));
        actualizarTextareaHistorial();
      }
      // Desactivar bot√≥n despu√©s de usar
      canRemoveFromHistory = false;
      document.getElementById('removeFromHistoryBtn').disabled = true;
    }

    // Borrar historial de fallos
    function esborrarHistorial() {
      if (confirm('Segur que vols esborrar tot l\'historial de fallos?')) {
        historialFallos = [];
        actualizarTextareaHistorial();
        localStorage.removeItem(LS_KEYS.HISTORIAL_FALLOS);
      }
    }

    // Actualizar textarea del historial
    function actualizarTextareaHistorial() {
      const textarea = document.getElementById('historialFallos');
      textarea.value = JSON.stringify(historialFallos, null, 2);
      // Actualizar contador de fallos con desglose por tema y tipo
      const fallosCount = document.getElementById('fallosCount');
      if (fallosCount) {
        const total = historialFallos.length;
        // Agrupar solo por subjectId y fallo.type
        const temas = {};
        historialFallos.forEach(fallo => {
          const tema = fallo.subjectId || '??';
          const tipo = fallo.type || '??';
          if (!temas[tema]) temas[tema] = {};
          if (!temas[tema][tipo]) temas[tema][tipo] = 0;
          temas[tema][tipo]++;
        });
        // Construir string de desglose
        const desglose = Object.entries(temas).map(([tema, tipos]) => {
          const sumaTema = Object.values(tipos).reduce((a,b) => a+b, 0);
          const tiposStr = Object.entries(tipos)
            .map(([tipo, n]) => `${tipo}:${n}`)
            .join(', ');
          return `${tema}:${sumaTema} <${tiposStr}>`;
        }).join(', ');
        fallosCount.textContent = `(${total}${desglose ? ', ' + desglose : ''})`;
      }
    }

    // Copiar historial al portapapeles
    function copiarHistorial() {
      const textarea = document.getElementById('historialFallos');
      textarea.select();
      document.execCommand('copy');
      toast.showToast('Historial copiat al portapapers!');
    }

    // Descargar historial como archivo JSON
    function baixarHistorial() {
      const username = localStorage.getItem(LS_KEYS.USER_NAME) || 'usuario';
      const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, -5);
      const filename = `Errores_${username}_${timestamp}.json`;
      
      const blob = new Blob([JSON.stringify(historialFallos, null, 2)], {type: 'application/json'});
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = filename;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    }

    // Inicializar al cargar la p√°gina
    document.addEventListener('DOMContentLoaded', function() {
      // Restaurar cronometro si existe en localStorage
      const savedCronometro = localStorage.getItem(LS_KEYS.CRONOMETRO);
      if (savedCronometro && !isNaN(savedCronometro)) {
        cronometroElapsed = parseInt(savedCronometro, 10);
        updateCronometroDisplay();
      }
      // Check if there is a saved question position and preloaded questions
      const savedPosition = localStorage.getItem(LS_KEYS.PREGUNTA_POSITION);
      const preloadedQuestions = localStorage.getItem(LS_KEYS.PREGUNTES_BARREJADES);

      if (savedPosition !== null && preloadedQuestions) {
        const userChoice = confirm('Vols continuar des de la pregunta guardada o comen√ßar de nou?\nPrem "Acceptar" per continuar o "Cancel¬∑lar" per reiniciar.');

        if (userChoice) {
          try {
            // Use preloaded questions and set the current question index
            preguntes = JSON.parse(preloadedQuestions);
            currentQuestion = parseInt(savedPosition, 10) || 0;
            answers = JSON.parse(localStorage.getItem(LS_KEYS.ANSWERS));
            //answers = new Array(preguntes.length).fill(null); // Initialize answers array
            showQuestion(currentQuestion); // Resume from the saved question
            // Iniciar cronometro si hay valor guardado
            if (cronometroElapsed > 0) {
              startCronometro();
            }
          } catch (e) {
            console.error('Error loading saved state:', e);
            // Fallback to loading questions normally
            if (loadQuestions()) {
              showQuestion(0);
              startCronometro();
            }
          }
        } else {
          // Clear saved state and restart
          localStorage.removeItem(LS_KEYS.PREGUNTA_POSITION);
          localStorage.removeItem(LS_KEYS.PREGUNTES_BARREJADES);
          localStorage.removeItem(LS_KEYS.CRONOMETRO);
          cronometroElapsed = 0;
          updateCronometroDisplay();
          if (loadQuestions()) {
            showQuestion(0);
            startCronometro();
          }
        }
      } else {
        // Load questions normally if no saved state exists
        if (loadQuestions()) {
          showQuestion(0);
          startCronometro();
        }
      }

      // Load previous error history if it exists
      try {
        const historialGuardado = localStorage.getItem(LS_KEYS.HISTORIAL_FALLOS);
        if (historialGuardado) {
          historialFallos = JSON.parse(historialGuardado);
          actualizarTextareaHistorial();
        } else {
          // Si no hay historial, actualizar el contador a 0
          const fallosCount = document.getElementById('fallosCount');
          if (fallosCount) fallosCount.textContent = '(0)';
        }
      } catch (e) {
        console.warn('Error cargando historial previo:', e);
      }
      // Ocultar el bot√≥n de eliminar encertada por defecto
      if (!isRepassingErrors) {
        document.getElementById('removeFromHistoryContainer').style.display = 'none';
      }
      resetInactivityTimer();
    });

  </script>
</body>
</html>
